/**
 * Generic forward-only solvability search for solitaire-like state spaces.
 *
 * The checker never relies on historical game states; it evaluates only the
 * current configuration and legal forward moves generated by an adapter.
 */
(function (globalScope) {
    class SolitaireStateSolvabilityChecker {
        constructor(adapter = {}) {
            this.adapter = adapter;
        }

        check(initialState, options = {}) {
            if (!this.adapter || typeof this.adapter.isSolved !== 'function') {
                return {
                    solved: false,
                    reason: 'invalid-adapter',
                    statesExplored: 0,
                    durationMs: 0
                };
            }

            const maxStates = Number.isFinite(options.maxStates)
                ? Math.max(1, options.maxStates)
                : 25000;
            const maxDurationMs = Number.isFinite(options.maxDurationMs)
                ? Math.max(1, options.maxDurationMs)
                : 1200;

            const startedAt = Date.now();
            const visited = new Set();
            const stack = [];
            const parentByKey = new Map();
            const moveByKey = new Map();
            const normalize = typeof this.adapter.normalizeState === 'function'
                ? this.adapter.normalizeState
                : (state) => JSON.stringify(state);

            const startState = this.cloneState(initialState);
            const preparedStart = this.prepareState(startState);
            if (!preparedStart) {
                return {
                    solved: false,
                    reason: 'exhausted',
                    statesExplored: 0,
                    prunedStates: 1,
                    durationMs: Date.now() - startedAt,
                    maxStates,
                    maxDurationMs
                };
            }

            const startKey = normalize(preparedStart);
            visited.add(startKey);
            stack.push(preparedStart);
            parentByKey.set(startKey, null);
            moveByKey.set(startKey, null);

            let statesExplored = 0;
            let prunedStates = 0;

            while (stack.length > 0) {
                if (statesExplored >= maxStates) {
                    return {
                        solved: false,
                        reason: 'state-limit',
                        statesExplored,
                        prunedStates,
                        durationMs: Date.now() - startedAt,
                        maxStates,
                        maxDurationMs
                    };
                }

                if ((Date.now() - startedAt) >= maxDurationMs) {
                    return {
                        solved: false,
                        reason: 'time-limit',
                        statesExplored,
                        prunedStates,
                        durationMs: Date.now() - startedAt,
                        maxStates,
                        maxDurationMs
                    };
                }

                const state = stack.pop();
                statesExplored++;

                if (this.adapter.isSolved(state)) {
                    const solvedKey = normalize(state);
                    const path = this.reconstructPath(solvedKey, parentByKey, moveByKey);
                    return {
                        solved: true,
                        reason: 'solved',
                        statesExplored,
                        prunedStates,
                        durationMs: Date.now() - startedAt,
                        maxStates,
                        maxDurationMs,
                        solutionMoves: path.moves,
                        solutionStateKeys: path.stateKeys
                    };
                }

                if (this.shouldPrune(state)) {
                    prunedStates++;
                    continue;
                }

                const rawMoves = typeof this.adapter.listMoves === 'function'
                    ? this.adapter.listMoves(state)
                    : [];
                const moves = Array.isArray(rawMoves) ? rawMoves : [];

                for (let i = moves.length - 1; i >= 0; i--) {
                    const move = moves[i];
                    if (!move || typeof this.adapter.applyMove !== 'function') continue;
                    const nextState = this.adapter.applyMove(state, move);
                    if (!nextState) continue;
                    const prepared = this.prepareState(nextState);
                    if (!prepared) {
                        prunedStates++;
                        continue;
                    }
                    if (this.shouldPrune(prepared)) {
                        prunedStates++;
                        continue;
                    }

                    const key = normalize(prepared);
                    if (visited.has(key)) continue;
                    visited.add(key);
                    parentByKey.set(key, normalize(state));
                    moveByKey.set(key, move);
                    stack.push(prepared);
                }
            }

            return {
                solved: false,
                reason: 'exhausted',
                statesExplored,
                prunedStates,
                durationMs: Date.now() - startedAt,
                maxStates,
                maxDurationMs
            };
        }

        reconstructPath(goalKey, parentByKey, moveByKey) {
            if (!goalKey || !parentByKey.has(goalKey)) {
                return { moves: [], stateKeys: [] };
            }
            const reversedStateKeys = [];
            const reversedMoves = [];
            let key = goalKey;
            while (key !== null && key !== undefined) {
                reversedStateKeys.push(key);
                const move = moveByKey.get(key);
                if (move) reversedMoves.push(move);
                key = parentByKey.get(key) || null;
            }
            const stateKeys = reversedStateKeys.reverse();
            const moves = reversedMoves.reverse();
            return { moves, stateKeys };
        }

        prepareState(state) {
            if (!state) return null;
            if (!this.adapter || typeof this.adapter.prepareState !== 'function') return state;
            return this.adapter.prepareState(state);
        }

        shouldPrune(state) {
            if (!state) return true;
            if (!this.adapter || typeof this.adapter.shouldPrune !== 'function') return false;
            return this.adapter.shouldPrune(state) === true;
        }

        cloneState(state) {
            if (state === null || state === undefined) return state;
            if (typeof structuredClone === 'function') {
                return structuredClone(state);
            }
            return JSON.parse(JSON.stringify(state));
        }
    }

    if (typeof module !== 'undefined' && module.exports) {
        module.exports = SolitaireStateSolvabilityChecker;
    }
    if (globalScope) {
        globalScope.SolitaireStateSolvabilityChecker = SolitaireStateSolvabilityChecker;
    }
})(typeof window !== 'undefined' ? window : globalThis);
