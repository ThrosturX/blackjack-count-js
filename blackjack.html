<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Casino Blackjack</title>
    
    <!-- =========================================
         FILE: style.css
    ========================================== -->
    <style>
        :root {
            --felt-color: #2d5e38;
            --felt-border: #4a3b2a;
            --gold: #f2c94c;
            --red: #eb5757;
            --black: #333;
            --green: #4caf50;
            --blue: #2196f3;
            --orange: #f2994a;
            --card-w: 70px;
            --card-h: 100px;
            --card-back-color: #b71c1c;
            --card-border-color: #555;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #111;
            color: white;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            user-select: none;
            padding-bottom: 90px;
            overflow: hidden;
        }

        /* --- Header --- */
        header {
            width: 100%;
            background: #000;
            padding: 10px 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--gold);
            box-sizing: border-box;
            z-index: 10;
            gap: 10px;
        }

        h1 { margin: 0; color: var(--gold); font-size: 1.4rem; width: 100%; text-align: center; }

        .game-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            width: 100%;
            justify-content: center;
        }

        .stats {
            background: #222;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.9rem;
            border: 1px solid #444;
        }

        /* --- Table Area --- */
        #table {
            position: relative;
            width: 95vw;
            max-width: 1400px;
            height: 75vh;
            margin-top: 20px;
            background: radial-gradient(circle, #357a44 0%, var(--felt-color) 90%);
            border-radius: 100px;
            border: 12px solid var(--felt-border);
            box-shadow: inset 0 0 60px rgba(0,0,0,0.7);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            overflow: hidden;
        }

        /* --- Center Overlay --- */
        #center-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 30;
            width: 100%;
        }
        #center-overlay.show { opacity: 1; }

        .overlay-text {
            font-size: 3rem;
            font-weight: 900;
            text-transform: uppercase;
            text-shadow: 0 0 20px rgba(0,0,0,0.8);
            line-height: 1.1;
        }
        .overlay-sub {
            font-size: 1.5rem;
            text-transform: uppercase;
            letter-spacing: 3px;
            margin-top: 10px;
            font-weight: bold;
        }

        .msg-win { color: var(--green); }
        .msg-lose { color: var(--red); }
        .msg-push { color: var(--blue); }
        .msg-bj { color: var(--gold); }
        .msg-shuffle { color: var(--gold); animation: pulse 1s infinite; }
        
        @keyframes pulse {
            0% { opacity: 0.8; }
            50% { opacity: 1; }
            100% { opacity: 0.8; }
        }

        .msg-timer { color: rgba(255,255,255,0.3); }
        .msg-auto { color: var(--blue); }
        
        .profit-indicator {
            display: block;
            font-size: 1.5rem;
            margin-top: 5px;
            font-family: monospace;
        }
        .profit-green { color: var(--green); }
        .profit-red { color: var(--red); }

        /* --- Visual Shoe (In Table, Right Side) --- */
        .shoe-container {
            position: absolute;
            top: 15%; /* Center vertically relative to dealer/player area */
            right: 20px;
            display: flex;
            flex-direction: row;
            align-items: center;
            z-index: 20;
            pointer-events: none;
        }

        .shoe-body {
            position: relative;
            width: 70px;
            height: 100px; /* Dealer card height */
            background: #111;
            border: 2px solid #555;
            border-radius: 4px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end; /* Cards stack from bottom */
            padding-bottom: 5px;
        }

        /* The Card Stack */
        .shoe-stack-cards {
            position: relative;
            width: 56px;
            height: 0%; /* Controlled by JS */
            /* Stacked effect with repeating gradient (Stripes) and borders */
            background: repeating-linear-gradient(
                to bottom,
                var(--card-back-color),
                var(--card-back-color) 4px, /* Card height */
                transparent 4px,
                transparent 5px, /* 1px gap between cards */
                #000 5px, /* Border line */
                #000 6px /* Reset */
            );
            /* Ensure it looks like a solid block of cards */
            border-left: 1px solid #333;
            border-right: 1px solid #333;
            max-height: 90px;
            transition: height 0.3s linear;
        }

        .shoe-base {
            position: absolute;
            bottom: 0;
            width: 80px;
            height: 15px;
            background: #000;
            border: 2px solid #444;
            border-radius: 4px;
            z-index: -1;
        }

        /* --- Dealer --- */
        #dealer-area {
            position: relative;
            top: 20px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 5;
            padding-right: 100px; /* Offset for shoe */
        }
        .score-pill {
            background: rgba(0,0,0,0.6);
            padding: 4px 12px;
            border-radius: 20px;
            color: white;
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 0.9rem;
            min-width: 40px;
            text-align: center;
        }

        /* --- Cards --- */
        .cards {
            display: flex;
            justify-content: center;
            height: var(--card-h);
        }
        
        .card {
            width: var(--card-w);
            height: var(--card-h);
            background: white;
            border-radius: 8px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
            display: flex;
            padding: 0; 
            box-sizing: border-box;
            margin-left: -45px;
            transition: transform 0.2s;
            position: relative;
        }
        .card:first-child { margin-left: 0; }
        .card.red { color: var(--red); }
        .card.black { color: var(--black); }

        /* Split / Cut Card Styling */
        .card.split-card {
            background: #fffbf0; /* Off-white */
            border: none;
            box-shadow: 0 0 0 2px #000, 2px 2px 5px rgba(0,0,0,0.3); /* Thicker look */
        }

        .val-top { 
            position: absolute; top: 4px; left: 4px; 
            font-size: 1.1rem; font-weight: bold; line-height: 1; 
            display: flex; flex-direction: column; align-items: center;
        }
        .val-top small { font-size: 0.7rem; }

        .suit-center { 
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%); font-size: 2.5rem; 
        }
        
        .val-bot { 
            position: absolute; bottom: 4px; right: 4px; 
            font-size: 1.1rem; font-weight: bold; line-height: 1; 
            transform: rotate(180deg); 
            display: flex; flex-direction: column; align-items: center;
        }
        .val-bot small { font-size: 0.7rem; }

        .card.hidden {
            /* RESTORING STRIPES */
            background: repeating-linear-gradient(
                45deg, 
                #b71c1c, 
                #b71c1c 10px, 
                #c62828 10px, 
                #c62828 20px
            );
            border: 2px solid white;
        }
        .card.hidden * { display: none; }

        /* --- Players --- */
        #seats {
            display: flex;
            justify-content: center;
            gap: 8px;
            padding-bottom: 20px;
            width: 100%;
            z-index: 5;
            padding-right: 80px;
        }

        .seat {
            width: 16%;
            min-width: 130px;
            height: 280px;
            background: rgba(0,0,0,0.15);
            border-radius: 12px;
            border: 2px solid rgba(255,255,255,0.1);
            display: flex;
            flex-direction: column;
            padding: 8px;
            position: relative;
        }

        .seat.turn { border-color: var(--gold); box-shadow: 0 0 15px var(--gold); }
        .seat.winner { border-color: var(--green); }
        .seat.loser { border-color: var(--red); opacity: 0.8; }
        .seat.push { border-color: var(--blue); }
        .seat.auto { border-color: var(--blue); }
        .seat.disabled { opacity: 0.5; }

        .seat-info {
            width: 100%;
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.8rem;
            color: #ddd;
        }
        .chip-stack { color: var(--gold); font-weight: bold; }

        .player-hand-area {
            flex-grow: 1;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .bet-bubble {
            position: absolute;
            top: 0px;
            background: var(--gold);
            color: #000;
            padding: 2px 8px;
            border-radius: 10px;
            font-weight: bold;
            font-size: 0.75rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        /* --- Controls --- */
        .controls {
            width: 100%;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 4px;
            margin-top: 10px;
            align-items: center;
            position: relative;
        }

        button {
            border: none;
            border-radius: 4px;
            padding: 6px 10px;
            font-weight: bold;
            cursor: pointer;
            transition: 0.2s;
            text-transform: uppercase;
            font-size: 0.75rem;
            white-space: nowrap;
        }

        .btn-sit { background: #444; color: white; width: 100%; padding: 10px; }
        
        .btn-standup { 
            position: absolute; top: -25px; right: 0; 
            background: #333; color: #888; font-size: 0.6rem; 
            padding: 3px 6px; border-radius: 4px; border: 1px solid #555; z-index: 10;
        }

        /* Toggles */
        .toggle-container {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            margin-bottom: 4px;
            cursor: pointer;
        }
        .toggle-label {
            font-size: 0.6rem;
            color: #aaa;
            margin-right: 4px;
            text-transform: uppercase;
        }
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 28px;
            height: 16px;
        }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #333;
            transition: .4s;
            border-radius: 34px;
            border: 1px solid #555;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 10px;
            width: 10px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider { background-color: var(--blue); }
        input:checked + .slider:before { transform: translateX(12px); }
        .toggle-switch.auto-bet input:checked + .slider { background-color: var(--gold); }


        .bet-controls { display: flex; width: 100%; gap: 4px; align-items: center; }
        
        .bet-input { 
            width: 100%; background: rgba(0,0,0,0.3); border: 1px solid #555; 
            color: white; padding: 6px; text-align: center;
            -moz-appearance: textfield; appearance: none;
            font-size: 0.8rem;
        }
        .bet-input::-webkit-outer-spin-button,
        .bet-input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }

        .btn-bet { background: var(--gold); color: black; flex: 1; padding: 6px; height: 30px; }
        .btn-bet:disabled { background: #555; color: #888; }
        
        .btn-clear { background: var(--red); color: white; padding: 6px 10px; height: 30px; width: auto; }

        .action-btn { 
            width: 32px; height: 32px; 
            border-radius: 50%; font-weight: bold; font-size: 0.9rem; 
            display: flex; align-items: center; justify-content: center; padding: 0; 
        }
        .btn-hit { background: var(--green); color: white; }
        .btn-stand { background: var(--red); color: white; }
        .btn-double { background: #2196f3; color: white; }
        .btn-split { background: #9c27b0; color: white; }

        /* --- Split Hands --- */
        .split-container {
            display: flex;
            gap: 4px;
            width: 100%;
            justify-content: center;
        }
        .mini-hand {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
            padding: 2px;
        }
        .mini-hand.active-split { border: 1px solid var(--gold); }
        .mini-hand .cards { height: 45px; }
        .mini-hand .card { width: 25px; height: 38px; margin-left: -15px; font-size: 0.5rem; }
        .mini-hand .suit-center { font-size: 1rem; }
        .mini-hand .val-top { font-size: 0.6rem; top: 2px; left: 2px; }
        .mini-hand .val-bot { font-size: 0.6rem; bottom: 2px; right: 2px; }
        .mini-hand .val-top small, .mini-hand .val-bot small { display: none; }

        /* --- Strategy Hint --- */
        #strategy-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background: #222;
            border-top: 2px solid #444;
            padding: 12px 20px;
            text-align: center;
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 4px;
        }
        .hint-label { color: #888; text-transform: uppercase; font-size: 0.7rem; letter-spacing: 1px; }
        .hint-text { color: var(--gold); font-weight: bold; font-size: 1.2rem; text-transform: uppercase; line-height: 1.2; }
        
        .count-hint {
            font-size: 0.85rem;
            margin-top: 4px;
            padding: 2px 8px;
            border-radius: 10px;
            text-transform: none;
            font-weight: normal;
        }
        .ch-high { background: rgba(76, 175, 80, 0.2); color: var(--green); border: 1px solid var(--green); }
        .ch-low { background: rgba(235, 87, 87, 0.2); color: var(--red); border: 1px solid var(--red); }
        .ch-neutral { background: rgba(255, 255, 255, 0.1); color: #aaa; border: 1px solid #888; }

    </style>
</head>
<body>

    <!-- =========================================
         FILE: index.html
    ========================================== -->
    <header>
        <h1>Blackjack</h1>
        <div class="game-controls">
            <div class="stats">Seats: 
                <select id="seat-select" style="background:#333; color:white;">
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5" selected>5</option>
                    <option value="6">6</option>
                    <option value="7">7</option>
                    <option value="8">8</option>
                    <option value="9">9</option>
                </select>
            </div>
            <div class="stats">Decks: 
                <select id="deck-select" style="background:#333; color:white;">
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                    <option value="6" selected>6</option>
                    <option value="7">7</option>
                    <option value="8">8</option>
                </select>
            </div>
            
            <div class="stats">Cards: <span id="cards-left">0</span></div>
            <div class="stats">Count: <span id="run-count">0</span></div>
        </div>
    </header>

    <main id="table">
        
        <!-- Center Overlay for Timer & Results -->
        <div id="center-overlay">
            <div id="overlay-main" class="overlay-text"></div>
            <div id="overlay-sub" class="overlay-sub"></div>
        </div>

        <!-- Visual Shoe (Right Side) -->
        <div class="shoe-container">
            <div class="shoe-body">
                <div class="shoe-stack-cards" id="shoe-stack-visual"></div>
            </div>
            <div class="shoe-base"></div>
        </div>

        <!-- Dealer Section -->
        <div id="dealer-area">
            <div class="score-pill" id="dealer-score">?</div>
            <div class="cards" id="dealer-cards"></div>
        </div>

        <!-- Players Section -->
        <div id="seats">
            <!-- Seats injected by JS -->
        </div>
    </main>

    <!-- Strategy Hint Bar -->
    <div id="strategy-bar">
        <span class="hint-label">Basic Strategy Hint</span>
        <span id="strategy-text" class="hint-text">Place bets to start</span>
        <span id="count-hint" class="count-hint ch-neutral"></span>
    </div>

    <!-- =========================================
         FILE: script.js
    ========================================== -->
    <script>
        /* --- CONSTANTS --- */
        const SUITS = ['♥', '♦', '♣', '♠'];
        const VALUES = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        const BET_TIME = 10;
        const MIN_TIMER = 3; 
        const PENETRATION = 0.75; 

        /* --- STATE --- */
        const state = {
            seatCount: 5,
            deckCount: 6,
            shoe: [],
            totalInitialCards: 0,
            cutCardReached: false,
            cutCardIndex: -1,
            runningCount: 0,
            dealer: { hand: [] },
            players: [], 
            phase: 'BETTING', // BETTING, SHUFFLING, DEALING, PLAYING, RESOLVING
            turnIndex: -1,
            splitIndex: -1,
            timer: null,
            timerVal: 0,
            isShuffling: false
        };

        const ui = {
            seats: document.getElementById('seats'),
            dealerCards: document.getElementById('dealer-cards'),
            dealerScore: document.getElementById('dealer-score'),
            overlay: document.getElementById('center-overlay'),
            overlayMain: document.getElementById('overlay-main'),
            overlaySub: document.getElementById('overlay-sub'),
            cardsLeft: document.getElementById('cards-left'),
            runCount: document.getElementById('run-count'),
            deckSelect: document.getElementById('deck-select'),
            seatSelect: document.getElementById('seat-select'),
            strategyText: document.getElementById('strategy-text'),
            countHint: document.getElementById('count-hint'),
            shoeStack: document.getElementById('shoe-stack-visual')
        };

        /* --- AUDIO STUB --- */
        function playSound(type) {
            console.log("NOTE: Implement audio for: " + type);
        }

        /* --- CARD CLASS --- */
        class Card {
            constructor(suit, val) {
                this.suit = suit;
                this.val = val;
                this.hidden = false;
                this.isSplitCard = false;
            }
            get num() {
                if (['J','Q','K'].includes(this.val)) return 10;
                if (this.val === 'A') return 11;
                return parseInt(this.val);
            }
            get count() {
                if (['10','J','Q','K','A'].includes(this.val)) return -1;
                if (['2','3','4','5','6'].includes(this.val)) return 1;
                return 0;
            }
            get color() { return (this.suit === '♥' || this.suit === '♦') ? 'red' : 'black'; }
        }

        /* --- INITIALIZATION --- */
        function init() {
            state.players = Array(state.seatCount).fill(null);
            createShoe(); 
        }

        function createShoe() {
            if (state.phase !== 'BETTING') return;

            state.shoe = [];
            state.runningCount = 0;
            state.cutCardReached = false;
            state.cutCardIndex = -1;
            state.totalInitialCards = 0;
            state.isShuffling = true;
            state.phase = 'SHUFFLING';

            // Create cards
            for (let i = 0; i < state.deckCount; i++) {
                for (let s of SUITS) {
                    for (let v of VALUES) {
                        state.shoe.push(new Card(s, v));
                        state.totalInitialCards++;
                    }
                }
            }
            // Fisher-Yates
            for (let i = state.shoe.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [state.shoe[i], state.shoe[j]] = [state.shoe[j], state.shoe[i]];
            }

            // Determine Cut Card
            state.cutCardIndex = Math.floor(state.totalInitialCards * (1 - PENETRATION));
            state.shoe[state.cutCardIndex].isSplitCard = true;

            // UI Updates
            ui.overlayMain.className = 'overlay-text msg-shuffle';
            ui.overlayMain.textContent = "Shuffling";
            ui.overlaySub.textContent = "Preparing Shoe...";
            ui.overlay.classList.add('show');
            
            ui.seats.innerHTML = ''; 
            renderSeats(); 

            ui.shoeStack.style.height = '0%';
            
            // Animation Sequence
            setTimeout(() => {
                const fillAnim = setInterval(() => {
                    let currentH = parseInt(ui.shoeStack.style.height) || 0;
                    if (currentH >= 100) {
                        clearInterval(fillAnim);
                        finishShuffle();
                    } else {
                        currentH += 5;
                        ui.shoeStack.style.height = `${currentH}%`;
                    }
                }, 20);
            }, 100);
        }

        function finishShuffle() {
            state.isShuffling = false;
            state.phase = 'BETTING';
            ui.overlay.classList.remove('show');
            
            // Trigger Auto-Bets for new round
            processAutoBets();
            
            render();
        }

        function updateStats() {
            ui.cardsLeft.textContent = state.shoe.length;
            const decksRem = Math.max(1, state.shoe.length / 52);
            const trueCount = (state.runningCount / decksRem).toFixed(1);
            ui.runCount.textContent = `${state.runningCount} (TC:${trueCount})`;

            const pct = (state.shoe.length / state.totalInitialCards);
            ui.shoeStack.style.height = `${pct * 100}%`;
        }

        function processAutoBets() {
            if(state.phase !== 'BETTING') return;
            state.players.forEach((p, idx) => {
                if(p && p.autoPlay && p.autoBet && !p.isReady) {
                    // Determine bet size based on Count
                    const decksRem = Math.max(1, state.shoe.length / 52);
                    const tc = state.runningCount / decksRem;
                    let betAmt = p.lastBet || 10;
                    if (tc >= 2) betAmt = 50;
                    else if (tc <= -2) betAmt = 10;
                    else betAmt = 20;
                    if (betAmt > p.chips) betAmt = p.chips;
                    placeBet(idx, betAmt);
                }
            });
        }

        /* --- GAME LOGIC --- */

        function placeBet(idx, amt) {
            if (state.phase !== 'BETTING') return;
            const p = state.players[idx];
            if (!p) return;
            
            if (isNaN(amt) || amt < 1) { playSound('error'); return; }
            if (amt > p.chips) { amt = p.chips; }
            if (amt === 0) { return; }

            playSound('chip');
            p.currentBet = amt;
            p.lastBet = amt; 
            p.chips -= amt;
            p.isReady = true; 

            renderSeat(idx); 
            setTimeout(() => {
                const active = state.players.filter(p => p !== null);
                if(state.phase === 'BETTING' && active.length > 0 && active.every(p => p.isReady)) {
                    startTimer();
                }
            }, 100);
        }

        function clearBet(idx) {
            if (state.phase !== 'BETTING') return;
            const p = state.players[idx];
            if (!p || !p.isReady) return;
            
            playSound('chip');
            p.chips += p.currentBet;
            p.currentBet = 0;
            p.isReady = false;
            renderSeat(idx);
        }

function toggleAuto(idx, type) {
    if (state.phase !== 'BETTING') return;
    const p = state.players[idx];
    if (!p) return;

    if (type === 'play') {
        p.autoPlay = !p.autoPlay;
        if (!p.autoPlay) {
            p.autoBet = false;
        }
    } else if (type === 'bet' && p.autoPlay) {
        p.autoBet = !p.autoBet;
        if (p.autoBet) {
            // Enable auto-bet: place bet immediately
            processAutoBets();
        } else {
            // Disable auto-bet: clear any existing bet and cancel timer
            clearBet(idx);
            if (state.timer) {
                clearInterval(state.timer);
                state.timer = null;
            }
        }
    }
    renderSeat(idx);
}

function startTimer() {
    if(state.timer) clearInterval(state.timer);
    state.timer = null;
    
    // Determine timer length: 3 seconds minimum, 10 seconds if there is a sitting human player that hasn't bet yet
    const hasHumanSittingUnbet = state.players.some(p => p && !p.autoPlay && !p.isReady);
    state.timerVal = hasHumanSittingUnbet ? BET_TIME : MIN_TIMER;
    
    ui.overlayMain.className = 'overlay-text msg-timer';
    ui.overlayMain.textContent = state.timerVal;
    ui.overlaySub.textContent = "Starting...";
    ui.overlay.classList.add('show');
    
    state.timer = setInterval(() => {
        state.timerVal--;
        ui.overlayMain.textContent = state.timerVal;
        if (state.timerVal <= 0) {
            clearInterval(state.timer);
            state.timer = null;
            ui.overlay.classList.remove('show');
            dealHands();
        }
    }, 1000);
}

        function dealHands() {
            state.phase = 'DEALING';
            playSound('shuffle');
            
            state.players.forEach(p => {
                if(p && p.isReady) {
                    p.hands = [{ cards: [], bet: p.currentBet, result: null, status: 'playing' }];
                    p.currentBet = 0;
                    p.isReady = false;
                } else if (p) {
                    p.hands = []; 
                }
            });
            state.dealer.hand = [];

            render();
            
            let deals = [];
            state.players.forEach((p, i) => { if(p && p.hands.length) deals.push({who:'p', idx:i, hand:0}); });
            deals.push({who:'d'});
            state.players.forEach((p, i) => { if(p && p.hands.length) deals.push({who:'p', idx:i, hand:0}); });
            deals.push({who:'d', hidden:true});

            let i = 0;
            function nextDeal() {
                if(i >= deals.length) {
                    checkBlackjack();
                    return;
                }
                const action = deals[i];
                if(action.who === 'd') {
                    const c = state.shoe.pop();
                    c.hidden = !!action.hidden;
                    state.dealer.hand.push(c);
                    if(!c.hidden) {
                        state.runningCount += c.count;
                        updateStats();
                        playSound('card');
                    }
                    renderDealer();
                } else {
                    const p = state.players[action.idx];
                    const c = state.shoe.pop();
                    state.runningCount += c.count;
                    updateStats();
                    playSound('card');
                    p.hands[0].cards.push(c);
                    renderSeat(action.idx);
                }
                i++;
                setTimeout(nextDeal, 200);
            }
            nextDeal();
        }

        function checkBlackjack() {
            const dScore = calcScore(state.dealer.hand);
            let activePlayers = state.players.filter(p => p && p.hands.length);
            let playing = false;

            activePlayers.forEach(p => {
                p.hands.forEach(h => {
                    const s = calcScore(h.cards);
                    if (s === 21) {
                        h.status = 'blackjack';
                        h.result = 'win'; 
                        if (dScore === 21) h.result = 'push';
                    } else {
                        playing = true;
                    }
                });
            });

            render();

            if (dScore === 21) {
                state.dealer.hand[1].hidden = false;
                renderDealer();
                state.runningCount += state.dealer.hand[1].count;
                updateStats();
                showOverlay("Dealer", "Blackjack!", "", "msg-bj");
                playSound('lose');
                setTimeout(endRound, 2000);
            } else if (!playing) {
                setTimeout(endRound, 1500);
            } else {
                state.phase = 'PLAYING';
                nextTurn();
            }
        }

        function nextTurn() {
            let found = false;
            for(let i=0; i<state.players.length; i++) {
                const p = state.players[i];
                if(p && p.hands.length) {
                    const hIdx = p.hands.findIndex(h => h.status === 'playing');
                    if(hIdx !== -1) {
                        state.turnIndex = i;
                        state.splitIndex = hIdx;
                        found = true;
                        
                        const score = calcScore(p.hands[hIdx].cards);
                        if(score === 21) {
                            setTimeout(playerStand, 500);
                        } else {
                            render();
                            updateStrategyHint();
                            
                            if(p.autoPlay) {
                                setTimeout(runAutoPlay, 800); 
                            }
                        }
                        return; 
                    }
                }
            }
            if(!found) {
                dealerTurn();
            }
        }

        function runAutoPlay() {
            const p = state.players[state.turnIndex];
            if (!p || !p.autoPlay) return;

            const h = p.hands[state.splitIndex];
            if (h.status !== 'playing') return; 

            const d = state.dealer.hand[0];
            const action = getStrategyHint(d, h.cards);
            
            showOverlay(`Player ${p.id+1}`, `Auto: ${action.toUpperCase()}`, "", "msg-auto");
            playSound('card'); 
            
            setTimeout(() => {
                if (action === 'Hit') playerHit();
                else if (action === 'Stand') playerStand();
                else if (action === 'Double') {
                    if(p.chips >= h.bet) playerDouble();
                    else playerHit(); 
                }
                else if (action === 'Split') playerSplit();
            }, 1000);
        }

        function playerHit() {
            const p = state.players[state.turnIndex];
            const h = p.hands[state.splitIndex];
            
            const c = state.shoe.pop();
            state.runningCount += c.count;
            updateStats();
            playSound('card');
            h.cards.push(c);
            
            ui.overlay.classList.remove('show');
            renderSeat(state.turnIndex);

            setTimeout(() => {
                if(calcScore(h.cards) > 21) {
                    h.status = 'bust';
                    h.result = 'lose';
                    playSound('lose');
                    ui.strategyText.textContent = ""; 
                    setTimeout(nextTurn, 800);
                } else if (calcScore(h.cards) === 21) {
                    ui.strategyText.textContent = ""; 
                    setTimeout(playerStand, 500);
                } else {
                    updateStrategyHint();
                    if(state.players[state.turnIndex].autoPlay) {
                        setTimeout(runAutoPlay, 500);
                    }
                }
            }, 500);
        }

        function playerStand() {
            ui.overlay.classList.remove('show');
            ui.strategyText.textContent = "";
            const p = state.players[state.turnIndex];
            const h = p.hands[state.splitIndex];
            h.status = 'stand';
            
            const nextSplit = p.hands.findIndex((hand, idx) => idx > state.splitIndex && hand.status === 'playing');
            if(nextSplit !== -1) {
                state.splitIndex = nextSplit;
                render();
                updateStrategyHint();
                setTimeout(() => {
                     if(calcScore(p.hands[nextSplit].cards) === 21) playerStand();
                     else if(p.autoPlay) setTimeout(runAutoPlay, 500);
                }, 500);
            } else {
                nextTurn();
            }
        }

        function playerDouble() {
            const p = state.players[state.turnIndex];
            const h = p.hands[state.splitIndex];
            if(p.chips < h.bet) { playSound('error'); return; }
            if(h.cards.length !== 2) return;

            playSound('chip');
            p.chips -= h.bet;
            h.bet *= 2;
            
            const c = state.shoe.pop();
            state.runningCount += c.count;
            updateStats();
            playSound('card');
            h.cards.push(c);
            h.status = 'stand';
            
            ui.overlay.classList.remove('show');
            ui.strategyText.textContent = "";
            renderSeat(state.turnIndex);
            setTimeout(nextTurn, 800);
        }

        function playerSplit() {
            const p = state.players[state.turnIndex];
            const h = p.hands[state.splitIndex];
            
            if(p.chips < h.bet) { playSound('error'); return; }
            const c1 = h.cards[0];
            const c2 = h.cards[1];
            if(c1.val !== c2.val) { playSound('error'); return; }

            playSound('chip');
            p.chips -= h.bet;

            const newHand = {
                cards: [c2],
                bet: h.bet, 
                status: 'playing',
                result: null
            };

            h.cards = [c1];
            p.hands.splice(state.splitIndex + 1, 0, newHand);

            const cFirst = state.shoe.pop();
            state.runningCount += cFirst.count;
            updateStats();
            playSound('card');
            h.cards.push(cFirst);

            const cSecond = state.shoe.pop();
            state.runningCount += cSecond.count;
            updateStats();
            playSound('card');
            newHand.cards.push(cSecond);

            renderSeat(state.turnIndex);
            updateStrategyHint();
            if(p.autoPlay) setTimeout(runAutoPlay, 500);
        }

        function dealerTurn() {
            state.phase = 'RESOLVING';
            state.turnIndex = -1;
            
            const hole = state.dealer.hand[1];
            hole.hidden = false;
            state.runningCount += hole.count;
            updateStats();
            playSound('card');
            renderDealer();

            let score = calcScore(state.dealer.hand);
            
            function loop() {
                if(score < 17) {
                    const c = state.shoe.pop();
                    state.runningCount += c.count;
                    updateStats();
                    playSound('card');
                    state.dealer.hand.push(c);
                    score = calcScore(state.dealer.hand);
                    renderDealer();
                    setTimeout(loop, 800);
                } else {
                    resolveRound();
                }
            }
            setTimeout(loop, 800);
        }

        function resolveRound() {
            const dScore = calcScore(state.dealer.hand);
            
            if (dScore > 21) {
                showOverlay("Dealer Busts!", "All Active Hands Win", "", "msg-win");
                playSound('win');
                setTimeout(finishRound, 1500);
            } else {
                ui.overlay.classList.remove('show');
                // Sequential Result Loop
                let pIndex = 0;
                
                function processNextPlayer() {
                    if (pIndex >= state.players.length) {
                        finishRound();
                        return;
                    }

                    const p = state.players[pIndex];
                    pIndex++;

                    if (!p || !p.hands.length) {
                        processNextPlayer();
                        return;
                    }

                    let hasAction = false;
                    
                    p.hands.forEach(h => {
                        if (h.result !== null) {
                             if (h.status === 'blackjack') {
                                const profit = h.bet * 1.5;
                                p.chips += h.bet + profit;
                                showOverlay(`Player ${p.id+1}`, "Blackjack", `+$${Math.floor(profit)}`, "msg-bj");
                                playSound('win');
                                hasAction = true;
                             } else if (h.status === 'bust') {
                                showOverlay(`Player ${p.id+1}`, "Bust", `-$${h.bet}`, "msg-lose");
                                playSound('lose');
                                hasAction = true;
                             }
                             return;
                        }

                        const pScore = calcScore(h.cards);
                        
                        if(pScore > dScore) {
                            h.status = 'win';
                            h.result = 'win';
                            p.chips += h.bet * 2;
                            showOverlay(`Player ${p.id+1}`, `Won`, `+$${h.bet}`, "msg-win");
                            playSound('win');
                            hasAction = true;
                        } else if (pScore < dScore) {
                            h.status = 'lose';
                            h.result = 'lose';
                            showOverlay(`Player ${p.id+1}`, `Lost`, `-$${h.bet}`, "msg-lose");
                            playSound('lose');
                            hasAction = true;
                        } else {
                            h.status = 'push';
                            h.result = 'push';
                            p.chips += h.bet;
                            showOverlay(`Player ${p.id+1}`, `Push`, "", "msg-push");
                            hasAction = true;
                        }
                    });

                    renderSeat(pIndex - 1);
                    if (hasAction) {
                        setTimeout(processNextPlayer, 1200);
                    } else {
                        processNextPlayer();
                    }
                }
                
                processNextPlayer();
            }
        }

function finishRound() {
    if(state.cutCardReached) {
        setTimeout(() => {
            showOverlay("Cut Card Reached", "Shuffling...", "", "msg-shuffle");
            setTimeout(createShoe, 1500);
        }, 1000);
    } else {
        state.phase = 'BETTING';
        // Trigger Auto-Bets for new round
        processAutoBets();
        render();
    }
}

function endRound() {
    state.phase = 'BETTING';
    // Trigger Auto-Bets for new round
    processAutoBets();
    render();
}

        function calcScore(cards) {
            let s = 0;
            let a = 0;
            cards.forEach(c => {
                if(c.hidden) return;
                s += c.num;
                if(c.val === 'A') a++;
            });
            while(s > 21 && a > 0) { s-=10; a--; }
            return s;
        }

        function getScoreDisplay(cards) {
            const score = calcScore(cards);
            if (isSoftHand(cards) && score < 21) {
                return `${score - 10} / ${score}`;
            }
            return score;
        }

        function isSoftHand(cards) {
            let score = 0;
            let aces = 0;
            for (let c of cards) {
                if(c.hidden) continue;
                score += c.num;
                if(c.val === 'A') aces++;
            }
            if (aces > 0) {
                let s = score - (aces - 1) - 10; 
                if (s <= 21) return true;
            }
            return false;
        }

        function getStrategyHint(dCard, pCards) {
            const dVal = dCard.num;
            const pScore = calcScore(pCards);
            const soft = isSoftHand(pCards);
            
            if (pCards.length === 2 && pCards[0].val === pCards[1].val) {
                const c = pCards[0].val;
                if (c === 'A' || c === '8') return "Split";
                if (c === '10' || c === '5') return soft ? "Stand" : (pScore >= 12 ? "Stand" : "Hit");
                if (c === '9') return (dVal !== 7 && dVal <= 9) ? "Split" : "Stand"; 
                if (c === '7') return (dVal <= 7) ? "Split" : "Hit";
                if (c === '6') return (dVal <= 6) ? "Split" : "Hit";
                if (c === '4') return (dVal === 5 || dVal === 6) ? "Split" : "Hit";
                if (c === '2' || c === '3') return (dVal <= 7) ? "Split" : "Hit";
            }

            if (soft) {
                if (pScore >= 20) return "Stand";
                if (pScore === 19) return (dVal === 6) ? "Double" : "Stand";
                if (pScore === 18) return (dVal <= 6) ? "Double" : (dVal === 7 || dVal === 8 ? "Stand" : "Hit");
                if (pScore === 17) return "Double";
                if (pScore === 16 || pScore === 15) return (dVal <= 6) ? "Double" : "Hit";
                if (pScore === 14 || pScore === 13) return (dVal === 5 || dVal === 6) ? "Double" : "Hit";
            }

            if (pScore >= 17) return "Stand";
            if (pScore >= 13 && pScore <= 16) return (dVal <= 6) ? "Stand" : "Hit";
            if (pScore === 12) return (dVal >= 4 && dVal <= 6) ? "Stand" : "Hit";
            if (pScore === 11) return "Double";
            if (pScore === 10) return (dVal <= 9) ? "Double" : "Hit";
            if (pScore === 9) return (dVal >= 3 && dVal <= 6) ? "Double" : "Hit";
            return "Hit";
        }

        function updateStrategyHint() {
            if (state.phase !== 'PLAYING') {
                ui.strategyText.textContent = "Place bets to start";
                ui.countHint.className = "count-hint ch-neutral";
                ui.countHint.textContent = "";
                return;
            }
            const p = state.players[state.turnIndex];
            const h = p.hands[state.splitIndex];
            const d = state.dealer.hand[0]; 
            
            const hint = getStrategyHint(d, h.cards);
            ui.strategyText.textContent = hint;

            const decksRem = Math.max(1, state.shoe.length / 52);
            const tc = (state.runningCount / decksRem);
            
            let countHintText = "";
            let countClass = "ch-neutral";

            if (tc >= 2) {
                countHintText = `Count High (+${tc.toFixed(1)}) - Bet Big`;
                countClass = "ch-high";
            } else if (tc <= -2) {
                countHintText = `Count Low (${tc.toFixed(1)}) - Bet Small`;
                countClass = "ch-low";
            } else {
                countHintText = `Count Average (${tc.toFixed(1)})`;
            }

            ui.countHint.textContent = countHintText;
            ui.countHint.className = `count-hint ${countClass}`;
        }

        function showOverlay(main, sub, amount, colorClass) {
            ui.overlayMain.className = `overlay-text ${colorClass}`;
            ui.overlayMain.textContent = main;
            
            let subHtml = sub;
            if(amount) {
                const color = amount.startsWith('+') ? 'profit-green' : 'profit-red';
                subHtml += `<span class="profit-indicator ${color}">${amount}</span>`;
            }
            ui.overlaySub.innerHTML = subHtml;
            
            ui.overlay.classList.add('show');
            
            if(colorClass === 'msg-win' || colorClass === 'msg-lose' || colorClass === 'msg-push' || colorClass === 'msg-auto' || colorClass === 'msg-bj') {
                setTimeout(() => { ui.overlay.classList.remove('show'); }, 1200);
            }
        }

        /* --- RENDERING --- */
        function createCardEl(card) {
            const div = document.createElement('div');
            div.className = `card ${card.color} ${card.hidden ? 'hidden' : ''} ${card.isSplitCard ? 'split-card' : ''}`;
            if(!card.hidden) {
                div.innerHTML = `<div class="val-top">${card.val}<small>${card.suit}</small></div>`;
                div.innerHTML += `<div class="suit-center">${card.suit}</div>`;
                div.innerHTML += `<div class="val-bot">${card.val}<small>${card.suit}</small></div>`;
            }
            return div;
        }

        function renderDealer() {
            ui.dealerCards.innerHTML = '';
            state.dealer.hand.forEach(c => ui.dealerCards.appendChild(createCardEl(c)));
            
            const hasHidden = state.dealer.hand.some(c => c.hidden);
            if(hasHidden && state.phase !== 'RESOLVING') {
                ui.dealerScore.textContent = state.dealer.hand[0].num;
            } else {
                ui.dealerScore.textContent = calcScore(state.dealer.hand);
            }
        }

        function getSeatHTML(idx) {
            const p = state.players[idx];
            const isGameActive = (state.phase === 'DEALING' || state.phase === 'PLAYING' || state.phase === 'RESOLVING');
            
            if(!p) {
                return `
                    <div class="seat" id="seat-${idx}" style="justify-content: flex-end;">
                        <div style="color:#aaa; margin-bottom:auto;">Empty</div>
                        <button class="btn-sit" onclick="sit(${idx})" ${isGameActive ? 'disabled' : ''}>Sit Down</button>
                    </div>
                `;
            }

            let classList = `seat ${state.turnIndex === idx && state.phase === 'PLAYING' ? 'turn' : ''}`;
            if(p.autoPlay) classList += ` auto`;
            
            // Only disable seat controls if it's NOT their turn AND game is active.
            // This fixes Issue 3
            const isMyTurn = (state.turnIndex === idx && state.phase === 'PLAYING');
            if(isGameActive && !isMyTurn) classList += ` disabled`;

            if(state.phase === 'BETTING' || state.phase === 'RESOLVING') {
                const wins = p.hands.filter(h => h.result === 'win').length;
                const loses = p.hands.filter(h => h.result === 'lose').length;
                const pushes = p.hands.filter(h => h.result === 'push').length;
                
                if(wins > 0 && loses === 0 && pushes === 0) classList += ' winner';
                else if (loses > 0 && wins === 0 && pushes === 0) classList += ' loser';
                else if (pushes > 0 && wins === 0 && loses === 0) classList += ' push';
            }

            let handHTML = '';
            let controlsHTML = '';

            const infoHTML = `<div class="seat-info"><span>P${idx+1}${p.autoPlay?' (Auto)':''}</span><span class="chip-stack">$${p.chips}</span></div>`;

            if(state.phase === 'BETTING') {
                controlsHTML = `
                    <button class="btn-standup" onclick="stand(${idx})">X</button>
                    <div class="toggle-container" onclick="toggleAuto(${idx}, 'play')">
                        <span class="toggle-label">Auto-Play</span>
                        <label class="toggle-switch">
                            <input type="checkbox" ${p.autoPlay ? 'checked' : ''} disabled>
                            <span class="slider"></span>
                        </label>
                    </div>
                    ${p.autoPlay ? `
                    <div class="toggle-container" onclick="toggleAuto(${idx}, 'bet')">
                        <span class="toggle-label">Auto-Bet</span>
                        <label class="toggle-switch auto-bet">
                            <input type="checkbox" ${p.autoBet ? 'checked' : ''} disabled>
                            <span class="slider"></span>
                        </label>
                    </div>` : ''}
                    ${!p.isReady ? `
                    <div class="bet-controls">
                        <input type="number" class="bet-input" id="bet-input-${idx}" value="${p.lastBet || 10}" min="10">
                        <button class="btn-bet" onclick="placeBet(${idx}, parseInt(document.getElementById('bet-input-${idx}').value))">Bet</button>
                    </div>` : `
                    <button class="btn-clear" onclick="clearBet(${idx})">Clear Bet</button>
                    `}
                `;
            } 
            else if(state.phase === 'PLAYING' && isMyTurn) {
                const h = p.hands[state.splitIndex];
                const canSplit = (h.cards.length === 2 && h.cards[0].val === h.cards[1].val && p.chips >= h.bet);
                const canDouble = (h.cards.length === 2 && p.chips >= h.bet);
                
                controlsHTML = `
                    <div class="controls">
                        <button class="action-btn btn-hit" onclick="playerHit()">H</button>
                        <button class="action-btn btn-stand" onclick="playerStand()">S</button>
                        ${canDouble ? `<button class="action-btn btn-double" onclick="playerDouble()">D</button>` : ''}
                        ${canSplit ? `<button class="action-btn btn-split" onclick="playerSplit()">Sp</button>` : ''}
                        <button class="btn-standup" onclick="stand(${idx})">X</button>
                    </div>
                `;
            } else {
                controlsHTML = `
                    <div class="controls" style="justify-content: flex-end;">
                        <button class="btn-standup" onclick="stand(${idx})">X</button>
                    </div>
                `;
            }

            if(p.hands.length === 0 && !p.isReady) {
                handHTML = '<div style="color:#aaa; font-style:italic;">Waiting...</div>';
            } else if (p.hands.length === 1 && !p.isReady) {
                const h = p.hands[0];
                handHTML = `
                    ${p.isReady ? `<div class="bet-bubble">$${p.currentBet}</div>` : ''}
                    ${h.status==='bust' ? '<div style="color:red; font-weight:bold; margin-bottom:5px;">BUST</div>' : ''}
                    <div class="cards">${h.cards.map(c => createCardEl(c).outerHTML).join('')}</div>
                    <div style="margin-top:5px; font-size:0.9rem;">${getScoreDisplay(h.cards)}</div>
                `;
            } else if (p.hands.length > 1) {
                handHTML = `<div class="split-container">`;
                p.hands.forEach((h, hIdx) => {
                    const isAct = (state.turnIndex === idx && state.splitIndex === hIdx);
                    handHTML += `
                        <div class="mini-hand ${isAct ? 'active-split' : ''}">
                            <div style="font-size:0.7rem; margin-bottom:2px;">Bet:${h.bet}</div>
                            <div class="cards">${h.cards.map(c => createCardEl(c).outerHTML).join('')}</div>
                            <div style="text-align:center; font-size:0.8rem;">${getScoreDisplay(h.cards)}</div>
                        </div>
                    `;
                });
                handHTML += `</div>`;
            }

            return `
                <div class="seat ${classList}" id="seat-${idx}">
                    ${infoHTML}
                    <div class="player-hand-area">${handHTML}</div>
                    <div class="controls">${controlsHTML}</div>
                </div>
            `;
        }

        function renderSeat(idx) {
            const old = document.getElementById(`seat-${idx}`);
            if(!old) return renderSeats(); 
            old.outerHTML = getSeatHTML(idx);
        }

        function renderSeats() {
            ui.seats.innerHTML = '';
            state.players.forEach((_, i) => {
                ui.seats.innerHTML += getSeatHTML(i);
            });
        }

        function render() {
            renderSeats();
        }

        window.sit = function(idx) {
            playSound('sit');
            state.players[idx] = { id: idx, chips: 1000, hands: [], currentBet: 0, isReady: false, lastBet: 10, autoPlay: false, autoBet: false };
            renderSeat(idx);
        }
        window.stand = function(idx) {
            if(state.phase !== 'BETTING') return;
            playSound('sit');
            state.players[idx] = null;
            renderSeats();
        }

        const originalPop = state.shoe.pop;
        state.shoe.pop = function() {
            const r = originalPop.apply(this);
            if (this.length === state.cutCardIndex) {
                state.cutCardReached = true;
            }
            return r;
        }

        ui.deckSelect.addEventListener('change', () => {
            if(state.phase === 'BETTING') {
                state.deckCount = parseInt(ui.deckSelect.value);
                createShoe();
            }
        });

        ui.seatSelect.addEventListener('change', () => {
            if(state.phase === 'BETTING') {
                const newVal = parseInt(ui.seatSelect.value);
                if (newVal < state.players.length) {
                    state.players = state.players.slice(0, newVal);
                } else {
                    for(let i = state.players.length; i < newVal; i++) {
                        state.players.push(null);
                    }
                }
                state.seatCount = newVal;
                render();
            }
        });

        init();
    </script>
</body>
</html>